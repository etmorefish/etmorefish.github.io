---
title: 进程线程协程
tags:
  - 操作系统
categories:
  - 操作系统
top: false
date: 2020-05-21 22:47:45
---

# 进程 线程 协程 并发与并行 **同步与异步** 阻塞与非阻塞

![进程、线程与协程](https://i.loli.net/2020/05/21/hDtAFyrIbxn89VX.jpg)

## 进程

> 进程是系统资源分配的最小单位, 系统由一个个进程(程序)组成,**进程的出现是为了更好的利用CPU资源使到并发成为可能。**
> 

* 第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。

* 第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行时），它才能成为一个活动的实体，我们称其为进程。

进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.

  > 通信问题:   由于进程间是隔离的,各自拥有自己的内存内存资源, *因此相对于线程比较安全*, 所以不同进程之间的数据只能通过 *IPC(Inter-Process Communication)* 进行通信共享.

## 线程

**线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能。**

> - 线程属于进程
> - 线程共享进程的内存地址空间
> - 线程几乎不占有系统资源
>   通信问题:  进程相当于一个容器,而线程而是运行在容器里面的,因此对于容器内的东西,线程是共同享有的,因此线程间的通信可以直接通过全局变量进行通信,但是由此带来的例如多个线程读写同一个地址变量的时候则将带来不可预期的后果,因此这时候引入了各种锁的作用,例如互斥锁等。

假设，一个文本程序，需要接受键盘输入，将内容显示在屏幕上，还需要保存信息到硬盘中。若只有一个进程，势必造成同一时间只能干一样事的尴尬（当保存时，就不能通过键盘输入内容）。若有多个进程，每个进程负责一个任务，进程A负责接收键盘输入的任务，进程B负责将内容显示在屏幕上的任务，进程C负责保存内容到硬盘中的任务。这里进程A，B，C间的协作涉及到了进程通信问题，而且有共同都需要拥有的东西-------文本内容，不停的切换造成性能上的损失。若有一种机制，可以使任务A，B，C共享资源，这样上下文切换所需要保存和恢复的内容就少了，同时又可以减少通信所带来的性能损耗，那就好了。是的，这种机制就是线程。**线程共享进程的大部分资源，并参与CPU的调度, 当然线程自己也是拥有自己的资源的，例如，栈，寄存器等等。**  此时，进程同时也是线程的容器。线程也是有着自己的缺陷的，例如健壮性差，若一个线程挂掉了，整一个进程也挂掉了，这意味着其它线程也挂掉了，进程却没有这个问题，一个进程挂掉，另外的进程还是活着。

- ***进程是系统分配资源的最小单位\***
- ***线程是CPU调度的最小单位\***
- *由于默认进程内只有一个线程,所以多核CPU处理多进程就像是一个进程一个核心*

## 协程

**协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在IO上的性能瓶颈。**

> - 协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等
> - 协程没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.
> - 原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。

## 小结

> 进程和线程的关系：
>
> * 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程
>
> * 资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源
>
> * cpu分配给线程，即真正在cpu上运行的是线程
>
> * 线程是最小的执行单元，进程是最小的资源管理单元

进程，线程，协程不断突破，更高效的处理阻塞，不断地提高CPU的利用率。但是并不是说，线程就一定比进程快，而协程就不一定不线程要快。具体还是要看应用场景。可以简单粗暴的把应用分为IO密集型应用以及CPU密集型应用。

**多核CPU，CPU密集型应用**
 此时多线程的效率是最高的，多线程可以使到全部CPU核心满载，又避免了协程间切换造成性能损失。当CPU密集型任务时，CPU一直在利用着，切换反而会造成性能损失，即便协程上下文切换消耗最小，但也还是有消耗的。

**多核CPU，IO密集型应用**
 此时采用多线程多协程效率最高，多线程可以使到全部CPU核心满载，而一个线程多协程，则更好的提高了CPU的利用率。

**单核CPU，CPU密集型应用**
 单进程效率是最高，此时单个进程已经使到CPU满载了。

**单核CPU，IO密集型应用**
 多协程，效率最高。例如，看了上面应该也是知道的了

## 并发与并行

![并行和并发](https://i.loli.net/2020/05/21/WDaPQO6CweJU5kb.png)

### 并行

并行就是指同一时刻有两个或两个以上的“工作单位”在同时执行，从硬件的角度上来看就是同一时刻有两条或两条以上的指令处于执行阶段。所以，多核是并行的前提，单线程永远无法达到并行状态。可以利用多线程和多进程到达并行状态。另外的，Python的多线程由于GIL的存在，对于Python来说无法通过多线程到达并行状态。

**并行的动机**：用更多的CPU核心更快的完成任务. 就像一个团队, 一个脑袋不够用了, 一个团队来一起处理一个任务。

### 并发

对于并发的理解，要从两方面去理解，1.并发设计 2.并发执行。先说并发设计，当说一个程序是并发的，更多的是指这个程序采取了并发设计。

**并发的动机**：在计算能力恒定的情况下处理更多的任务, 就像我们的大脑, 计算能力相对恒定, 要在一天中处理更多的问题, 我们就必须具备多任务的能力. 现实工作中有很多事情可能会中断你的当前任务, 处理这种多任务的能力就是你的并发能力。

并发设计的标准：**使多个操作可以在重叠的时间段内进行** ，这里的重点在于**重叠的时间内**， 重叠时间可以理解为一段时间内。例如：**在时间1s秒内**,  具有IO操作的task1和task2都完成，这就可以说是并发执行。所以呢，单线程也是可以做到并发运行的。当然啦，并行肯定是并发的。一个程序能否并发执行，**取决于设计，也取决于部署方式**。例如, 当给程序开一个线程（协程是不开的），它不可能是并发的，因为在重叠时间内根本就没有两个task在运行。当一个程序被设计成完成一个任务再去完成下一个任务的时候，即便部署是多线程多协程的也是无法达到并发运行的。

**并行与并发的关系**: **并发的设计使到并发执行成为可能，而并行是并发执行的其中一种模式**。

## **同步与异步**
同步和异步关注的是**消息通信机制**(synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，***调用\*在发出之后，这个调用就直接返回了，所以没有返回结果**。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

## 阻塞与非阻塞
阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态.**

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

